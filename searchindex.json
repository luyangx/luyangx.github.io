{"categories":[{"title":"学习笔记","uri":"https://www.luyang.ink/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"工具","uri":"https://www.luyang.ink/categories/%E5%B7%A5%E5%85%B7/"}],"posts":[{"content":"衡量数据库性能的指标, 一般有2个指标: 响应时间和吞吐率. 响应时间又包括等待时间和执行时间. 调优的目的是降低响应时间, 提高吞吐率.\n主要设置参数 innodb_buffer_pool_size 缓冲池大小, 专用服务器, 保证操作系统有足够的可用内存后, 剩余分配给 buffer pool\ninnodb_flush_method 数据刷新到磁盘方式\n fdatasync: 默认值, InnoDB 使用 fsync() 系统调用来刷新数据和日志文件 O_DSYNC: InnoDB 使用 O_DSYNC 打开并刷新日志文件, 数据文件刷新还是用 fsync() O_DIRECT: InnoDB 使用 O_DIRECT 打开并刷新数据和日志文件  建议设为 O_DIRECT, 可以避免 InnoDB 的 double write, 让数据库跳过文件系统缓冲直接和设备交互. 设备需要高可用\ninnodb_log_file_size 日志文件大小, 可以通过 show global status like 'Innodb_os_log_written' 来查看一段时间内的日志量, 经验值: 256~512MB\ninnodb_flush_log_at_trx_commit 事务提交时刷新日志方式\n 0: 日志缓冲每秒被写到日志文件中并刷新到磁盘, 事务提交时不进行任何操作 1: 默认值, 事务提交时, 日志缓冲被写到日志文件中并刷新到磁盘 2: 事务提交时, 日志缓冲被写到日志文件中, 但不会刷新到磁盘  对数据安全性有要求的建议设置1, 否则可以设置2, 对多丢失1s事务. 1可能会导致I/O成为瓶颈\nsync_binlog MySQL多长时间将 binary log 刷新到磁盘\n建议 8~20, 可兼顾效率和安全, 如果设置1, I/O可能会成为瓶颈\ninnodb_thread_concurrency 并发线程数, 官方建议设置为: 处理器数 + 磁盘数, 对于高并发事务, 应该设置的更大一些.\ninnodb_max_dirty_pages_pct dirty page 在缓冲池中的最大百分比, 默认: 75, 建议: 50~75\nread_buffer_size 每个线程连续扫描时为扫描的每个表分配的缓冲区大小(字节).\nread_rnd_buffer_size 排序后, 按照排序后的顺序读取行时, 则通过该缓冲区读取, 避免搜索磁盘. 设置较大值可以改进 ORDER BY 性能, 切记, 勿将全局变量设置为较大值, 相反, 只为需要大查询的客户端更改会话变量即可\nquery_cache_size 为缓存查询结果分配的内存大小, 默认:0(禁用). 对应写操作频繁的应用可以禁用. 生成环境建议设置64MB~256MB, 可以满足绝大部分业务. 还需要同时设置 query_cache_type=1\njoin_buffer_size 用于完全链接(当不适用索引时)的缓冲区大小, 默认: 256KB\nmax_connections 允许并行最多客户端连接数, 最大值: 100000\nmax_connect_errors 如果中断与主机的联机超过了该数目, 则该主机会阻塞后面的链接. 建议设置 5000 以上\nskip-name-resolve 不需要解析客户端链接的主机名, 用IP, 或在 hosts 文件中指定 host/ip\n内存优化 避免使用 swap swap 会将最近不常用的内存数据转存到下一级存储里(磁盘), 需要的时候再重新载入到内存. 频繁进行 swap 操作, 会大大增加磁盘的延时时间, 导致性能问题.\n避免 swap 方法:\n 设置 memlock, 将 MySQL InnoDB buffer 锁定在内存, 用不使用 swap 使用大内存页, Linux系统的大内存页不会被 swap 出去 设置 vm.swappiness=0, 减少 swap 的可能 禁用 NUMA 或调整 NUMA, Linux 的 NUMA 技术  CPU 优化 理论上, 如果操作比较集中与某一些资源, 瓶颈多是锁和队列等待, 那么应该选取更强劲的 CPU; 如果操作分散与输多不想干资源商, 并发度高, 可用增加 CPU 数量 n j mlyp\n","id":0,"section":"posts","summary":"\u003cp\u003e衡量数据库性能的指标, 一般有2个指标: 响应时间和吞吐率. 响应时间又包括等待时间和执行时间. 调优的目的是降低响应时间, 提高吞吐率.\u003c/p\u003e","tags":["MySQL"],"title":"MySQL Server调优","uri":"https://www.luyang.ink/2016/11/mysql-server-turning/","year":"2016"},{"content":"EXPLAIN 命令输出的信息可以告诉我们 MySQL 是怎么执行 SQL 语句的, 访问了哪些表, 以及如何访问数据的. 其中有很重要的索引使用信息, 可以根据此信息来判断 SQL 是否需要优化\nEXPLAIN 命令输出信息示例:\nEXPLAIN SELECT * FROM t1 WHERE col1=1 AND col2=\u0026quot;ab\u0026quot; AND col3=0;     id select_type table partitions type possible_keys key key_len ref rows filtered Extra     1 SIMPLE station_gas NULL ref sid_num sid_num 262 const,const 1 10.00 Using where    id 表示查询中执行 SELECT 字句或操作表的顺序. id相同, 则执行顺序自上而下; 如果是子查询, id的序号会递增, id值越大优先级越高, 越先被执行\nselect_type 查询中每个 SELETC 字句的类型(简单或复杂)\n SIMPLE: 查询中不包含子查询或 UNION 查询中若包含热河负责的子部分, 最外层查询标记为 PRIMARY 在 SELECT 或 WHERE 列表中包含子查询, 该子查询标记为 SUBQUERY 在 FROM 列表中包含的子查询标记为 DERIVED(衍生) SELECT 出现在 UNION 之后, 标记为 UNION, UNION 出现在 FROM 字句的子查询中, 外层 SELECT 标记为 DERIVED 从 UNION 表中获取结果的 SELECT 标记为 UNION RESULT DERIVED 衍生表  type MySQL 在表中以什么样的方式找到所需数据, 又称\u0026quot;访问类型\u0026rdquo;, 常见访问类型如下: (由最差到最好)\n ALL: full table scan, 全表扫描 index: full index scan, 扫描索引 range: 索引访问扫描, 常用与 between, \u0026lt;, \u0026gt; 等查询 ref: 非唯一性索引扫描, 常用与 使用非唯一索引或唯一索引的非唯一前缀进行查找 eq_ref: 唯一索引扫描, 常用语主键或唯一索引扫描 const/system: 当 MySQL 对查询的某部分进行优化时, 并转换为一个常量时, 如下示例:  # set optimizer_switch='derived_merge=off'; # MySQL5.7 derived_merge 默认 on, 是否合并衍生表或视图 SELECT * FROM (SELECT * FROM t1 WHERE id=1) t2     id select_type table partitions type possible_keys key key_len ref rows filtered Extra     1 PRIMARY  NULL system NULL NULL NULL NULL 1 100.00 NULL   2 DERIVED users NULL const PRIMARY PRIMARY 4 const 1 100.00 Using     NULL: MySQL 在优化过程中分解语句, 执行时可以不用访问表或索引.  possible_keys 给出 MySQL 能使用哪个索引在表中找到数据行, 查询字段上若有索引, 该索引会被列出, 但不一定会使用\nkey MySQL 在执行查询中实际用到的索引, 若没有索引可用, 显示 NULL\nkey_len 索引所使用的字节数\nref 表连接匹配条件, 即哪些列或常量被用于查找索引列上的值, WHERE 中 col1='abc\u0026rsquo;\nrows MySQL 根据表统计信息和索引选用信息, 估算出所需读取的行数\nExtra 此列显示的信息十分重要\n using index: SELECT 使用了覆盖索引 using where: MySQL服务器在存储引擎收到数据后进行过滤(Post-filter) using temporary: MySQL使用临时表来存储结果集, 常见于排序和分组查询 using filesort: MySQL无法利用索引完成排序, 性能差 ","id":1,"section":"posts","summary":"\u003cp\u003eEXPLAIN 命令输出的信息可以告诉我们 MySQL 是怎么执行 SQL 语句的, 访问了哪些表, 以及如何访问数据的. 其中有很重要的索引使用信息, 可以根据此信息来判断 SQL 是否需要优化\u003c/p\u003e","tags":["MySQL"],"title":"MySQL EXPLAIN","uri":"https://www.luyang.ink/2016/10/mysql-explain/","year":"2016"},{"content":"学习记录 InnoDB 复制相关内容\n工作原理 复制(replication)是MySQL数据库提供的一种高可用高性能的解决方案, replication 的工作原理分为以下3个步骤:\n 主服务器(master)把数据更改记录到二进制日志(binlog)中 从服务器(slave)把主服务器的二进制日志复制到自己的中继日志(relay log)中 从服务器(slave)重做中继日志中的日志, 把更改应用到自己的数据库上, 以达到最终一致性  复制过程会涉及到3种线程\n Master Binlog dump thread: 每连接一个 slave 就会为其创建一个 Binlog dump thread Slave I/O thread: 获取 master 发送的 binary log, 保存在本地 relay log 中 Slave SQL thread: 读取 relay log 中的内容, 应用到自己的数据库中  半同步复制 Semisynchronous Replication MySQL 复制默认是异步的, master 将数据更改时间写入到 binary log 中, 但并不知道相连的 slave 是否完成了同步, 这个时候 master 崩了, slave 就会丢失 master 中未来得及同步的数据, 造成数据不一致.\n slave 连接 master 时, 告知是否支持半同步复制 master 开启半同步复制, slave 中必须至少有一个也要开启半同步复制. master 中一个事务提交后会一直等待 slave 的 \u0026ldquo;已收到\u0026rdquo; ack, 或者知道超时 slave 收到 master 事务提交事件日志后, 将其写入到 relay log 磁盘文件中, 才会回复 master \u0026ldquo;已收到\u0026rdquo; 如果超时且没有任何 slave 回复, master 就恢复到 异步复制 模式, 知道其中一个支持半同步复制的 slave 重新连上 master, master 才会再次切到 半同步复制 模式  实践 通过 docker 安装 MySQL 5.7\ndocker pull mysql:5.7   创建目录 ~/mysql/master, ~/mysql/slave, 分别在目录中添加 my.cnf 配置文件, 增加用于复制的设置  # master [mysqld] server-id = 10 // 唯一\rlog-bin = mysql-bin // log文件名前缀, 例: mysql-bin.000001, mysql-bin.000002... # slave [mysqld] server-id = 101\rlog-bin = mysql-bin   运行master, port=3306  docker run --name=mysql-m1 -e MYSQL_ROOT_PASSWORD=111111 -d -p 3306:3306 -v ~/mysql/master:/etc/mysql/conf.d -d mysql:5.7   在 master 中创建用于复制的用户  mysql\u0026gt; CREATE USER 'repl'@'%.example.com' IDENTIFIED BY 'password'; mysql\u0026gt; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.example.com';   通过 show master status\\G 查看 master 状态  mysql\u0026gt; show master status\\G\r*************************** 1. row ***************************\rFile: mysql-bin.000001 // binlog文件名, slave复制时用到\rPosition: 455 // binlog文件位置, slave复制时用到\r1 row in set (0.00 sec)   运行 slave, port=3307(同一台机器,不同端口)  docker run --name=mysql-s1 -e MYSQL_ROOT_PASSWORD=111111 -d -p 3307:3306 -v ~/mysql/slave:/etc/mysql/conf.d -d mysql:5.7   在 slave 进行同步设置  change master to master_host ='172.18.0.3', // master ip地址 master_port=3306, // master 端口号, 默认3306 master_user='mysql_rep', // master创建的复制账号 master_password='111111', // master创建的复制账号的密码 master_log_file='mysql-bin.000001', // master bin 文件, 通过在 master 中执行 show master status; 查看 master_log_pos=0; // 同步 master bin log 文件位置, 通过在 master 中执行 show master status; 查看, 0:从头开始   启动 slave, 并查看其状态  # 启动slave start slave; ## 查看salve状态 show slave status\\G\r*************************** 1. row ***************************\rSlave_IO_State: Waiting for master to send event\rMaster_Host: 172.18.0.3\rMaster_User: mysql_rep\rMaster_Port: 3306\rConnect_Retry: 60\rMaster_Log_File: mysql-bin.000001 // 目前复制master的文件index\rRead_Master_Log_Pos: 455 // 最新复制文件位置\rRelay_Log_File: 5bf0e96072ce-relay-bin.000004 // slave中继日志\rRelay_Log_Pos: 668\rRelay_Master_Log_File: mysql-bin.000002\rSlave_IO_Running: Yes // Yes 表示允许正常, 很重要\rSlave_SQL_Running: Yes // Yes 表示允许正常, 很重要\rReplicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0\rLast_Error: Skip_Counter: 0\rExec_Master_Log_Pos: 455\rRelay_Log_Space: 929\rUntil_Condition: None\rUntil_Log_File: Until_Log_Pos: 0\rMaster_SSL_Allowed: No\rMaster_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0\rMaster_SSL_Verify_Server_Cert: No\rLast_IO_Errno: 0 // 非0代表有错误发送\rLast_IO_Error: // 错误信息\rLast_SQL_Errno: 0\rLast_SQL_Error: ...省略 ","id":2,"section":"posts","summary":"\u003cp\u003e学习记录 InnoDB 复制相关内容\u003c/p\u003e","tags":["MySQL"],"title":"MySQL 之 InnoDB . 复制","uri":"https://www.luyang.ink/2016/10/mysql-innode-rep/","year":"2016"},{"content":"学习记录 InnoDB 事务相关内容\n事务会把数据库从一种一致状态转换为另一种一致状态.\nInnoDB存储引擎中的事物完全符合ACID特性\n 原子性(atomicity): 所有操作要么都执行成功, 要么都不执行, 不会出现未知情况 一致性(consistency): 事务将数据库从一种状态转变为下一种一致的状态 隔离性(isolation): 事务之间相互分离, 事务提交前对其他事务都不可见 持久性(durability): 事务一旦提交, 其结果是永久性的  事务的实现 redo 重做日志 重做日志用来实现事务的持久性, 由内存中的重做日志缓冲(redo log buffer)和重做日志文件(redo log file)组成\nInnoDB 通过 Force Log at Commit 机制实现事务持久性, 既当事务提交(COMMIT)时, 必须先将该事务的所有日志写入到重做日志文件进行持久化(fsync), 待事务的COMMIT操作完成才算完成.\nInnoDB存储引擎中, 重做日志由2部分组成:\n redo log 用来保证事务的持久性, 顺序写 undo log 用来帮助事务回滚及MVCC功能, 随机读写  innodb_flush_log_at_trx_commit 参数用来空值重做日志刷新到磁盘的策略:\n 0: 事务提交时不进行 fsync, 由 master thread 每1秒进行一次重做日志 fsync 1: 默认值, 事务提交时必须调用异常 fsync 操作 2: 事务提交时将重做日志写入重做日志文件缓存中, 依赖操作系统 fsync  undo 将数据库逻辑的回复到执行预计或事务之前的样子\nInnoDB 存储引擎中 MVCC 的实现是通过 undo 日志来完成的. 当用户读取一行记录时, 若该记录已被其他事务占用, 当前事务可以通过 undo 日志读取之前的行版本信息, 也就是非锁定读.\npurge delete 和 update 操作可能并不直接删除原有的数据. delete操作将记录 delete flag 设置为1, 并不立即删除, 因为 MVCC, 删除时, 可能存在其他事务引用了该条记录, 需要保存记录之前的版本. 真正删除时又 purge 来操作, 若该行记录已不被任何其他事务引用, 则进行真正的 delete 操作.\ngroup commit 一次 fsync 可以刷新确保多个事务日志写入文件\n","id":3,"section":"posts","summary":"\u003cp\u003e学习记录 InnoDB 事务相关内容\u003c/p\u003e","tags":["MySQL"],"title":"MySQL 之 InnoDB . 事务","uri":"https://www.luyang.ink/2016/10/mysql-innodb-trx/","year":"2016"},{"content":"学习记录 InnoDB 锁相关内容\nInnoDB存储引擎中的锁 锁类型 行级锁:\n 共享锁(S Lock), 允许事务读一行数据 排它锁(X Lock), 允许事务删除或更新一行数据  行级锁兼容性:\n   X S      X 不兼容 不兼容   S 不兼容 兼容    意向锁 Intention Lock:\n 意向共享锁(IS Lock), 事务想要获得一张表中某几行的共享锁 意向排他锁(IX Lock), 事务想要获得一张表中某几行的排他锁  意向锁兼容性:\n   IS IX X S      IS 兼容 兼容 兼容 不兼容   IX 兼容 兼容 不兼容 不兼容   S 兼容 不兼容 兼容 不兼容   X 不兼容 不兼容 不兼容 不兼容    一致性非锁定读 一致性非锁定读(consistent nonlocking read)是指 InnoDB 存储引擎通过多版本控制(multi versioning)的方式来读取当前执行时间数据库中行的数据. 如果读取的数据正在执行 DELETE 或 UPDATE 操作, 这时读取不会因此而等待行上的锁释放. 相反地, 获取读取行地一个快照数据. 提高了数据库的并发性.\n READ COMMITTED: 读取最新快照数据 REPEATABLE READ: 读取事务开始时的快照数据  锁地算法 行锁3种算法\n Record Lock: 单个行记录上的锁 Gap Lock: 间隙锁, 锁定一个范围, 但不包含记录本身 Next-Key Lock: 锁定一个范围, 并且锁定记录本身, 解决幻读  幻想问题(Phantom Problem): 同一事务下, 多次执行同样的SQL语句可能导致不同的结果, 第二次的SQL可能返回之前不存在的行.\n锁的问题  脏读: 不同事务下, 当前事务可以读到其他事务未提交的数据. 不可重复读: 一个事务中多次读取同一数据集合, 数据不一样. 死锁: 2个或2个以上的事务在执行过程中, 因争夺资源而造成的一种互相等待的现象. 可以用设置超时时间来避免死锁 innodb_lock_wait_timeout ","id":4,"section":"posts","summary":"\u003cp\u003e学习记录 InnoDB 锁相关内容\u003c/p\u003e","tags":["MySQL"],"title":"MySQL 之 InnoDB . 锁","uri":"https://www.luyang.ink/2016/10/mysql-innodb-lock/","year":"2016"},{"content":"学习记录 InnoDB 索引相关内容\nB+ Tree B+树时为了磁盘或其他直接存取辅助设备设计的一种平衡查找树. 所有记录节点都是按键值大小顺序存放在同一层叶子节点上, 由各个叶子节点指针进行连接.\nB+ Tree 插入 B+ 树在保证插入后叶子节点记录依然顺序, 还需要考虑下面3种情况\n可以参考 B+树可视化操作-Insert\nB+ Tree 删除 B+ 树使用填充因子(fill factor)来控制树的删除变化, 50%是最小值, 删除操作同样要保证叶子节点记录依然顺序\n可以参考 B+树可视化操作-Delete\nB+ Tree 索引 假设1个page=16KB, 平均每行记录大小=100字节, 则每个page可以保存的记录数量=160, 那么, 高度=2的B+tree可以保存25600行记录(16的2次方), 高度=3可以保存4 096 000行记录(16的3次方), 高度=4可以保存655 360 000行记录(16的4次方), B+tree高度一般在 2-4 层\n聚集索引 Clustered Index 表中数据按主键顺序存放, 每张表只有1个聚集索引. 叶子节点保存着数据, 叶子节点是双向链表. 聚集索引是逻辑上连续的, 物理上不一定连续. 对主键排序和范围查找非常快. EXPLAIN 中 key=PRIMARY\n二级索引 Secondary Index 每张表可以有多个二级索引. 叶子节点不包含行记录的全部数据, 除了包含主键外, 还包含1个书签(bookmark). 该书签用来告诉InnoDB哪里可以找到与索引相关的数据, 与聚集索引关系如下图\n高度=3的二级索引, 查找数据会进行3次二级索引比对找到指定主键, 再在高度=3的聚集索引中进行3次比对找到数据所在的page, 一共需要6次逻辑IO\nCardinality 值 Cardinality 标识索引中不重复记录数的预估值. 可以根据此值尽可能接近1来评估索引是否是高选择性.\nCardinality 是预估值, 不是准确的. InnoDB更新其值策略为:\n 表中 1/16 的数据已发生变化 stat_modified_counter \u0026gt; 2 000 000 000  Cardinality 统计和更新操作过程\n 取 B+树 叶子节点的数量, 记为A 随机取 B+树 索引中的8个叶子节点. 统计每个不同记录的个数, 记为P1,P2,\u0026hellip;P8 根据采样信息给出预估值 Cardinality=(P1+P2+\u0026hellip;+P3)*A/8  B+ Tree 索引使用 联合索引 多个列进行索引\n覆盖索引 从二级索引中可以得到查询记录, 不需要再查询聚集索引\n如果有联合索引(a, b), 需要统计数据\nSELECT COUNT(*) FROM orders WHERE b\u0026gt;10 and b\u0026lt;100;  对应统计数据优化器会选择使用该索引进行统计\nIndex Condition Pushdown ICP 优化 在取出索引的同时, 判断是否可以进行WHERE条件过滤掉多余数据, 而不是根据索引取出数据后再进行WHERE过滤, 大大减少上层对记录的fetch, 提高数据库性能.\n","id":5,"section":"posts","summary":"\u003cp\u003e学习记录 InnoDB 索引相关内容\u003c/p\u003e","tags":["MySQL"],"title":"MySQL 之 InnoDB . 索引","uri":"https://www.luyang.ink/2016/09/mysql-innodb-index/","year":"2016"},{"content":"学习记录 InnoDB 表相关内容\n索引组织表 InnoDB 存储引擎中, 表都是按照主键顺序组织存放的, 称之为索引组织表(index organized table).\nInnoDB 选择主键规则:\n 显式设置自增主键 非空唯一索引(Unique NOT NULL), 优先选择建表时第一个非空唯一索引, `字段NOT NULL\u0026amp;\u0026amp;UNIQUE KEY(字段) 自动创建一个6字节大小的指针  逻辑存储结构 InnoDB存储引擎所有数据都保存在表空间(tablespace). 表空间由 段(segment), 区(extent), 页(page)组成, 如下图:\nRow 中保存这表中每一行数据\n表空间 tablespace 所有数据都保存在共享表空间 ibdata1, 可以通过设置 innodb_file_per_table 给每张表分配单独的表空间. 单独表空间只保存数据, 索引, Change Buffer Bitmap页, 其他数据, 如undo信息, Change Buffer index页, 事务信息, Double write buffer等还是保存在共享表空间中.\n行记录格式 InnoDB 1.0.x 版本之前有2种行记录格式Compact, Redundant, 之后版本提供了Compressed, Dynamic\nCompact    变长字段长度列表 NULL标识位 记录头信息 列1数据 列2数据 \u0026hellip; 事务ID列 回滚指针列 rowid列     变长字段长度列表, 列长度 \u0026lt; 255字节, 用1字节保存长度, 否则用2字节保存长度. MySQL中Varchar最大长度限制:65535 = 2的16次方-1 NULL标识位, NOT NULL=0, NULL=1, 列NULL数据不占用实际空间 记录头信息, 固定5字节, 40位 rowid列, 如果没有定义主键, rowid为隐藏主键列  Redundant MySQL 5.0 之前使用 为了兼容以前的行记录格式\n行溢出数据 Compact, Redundant 保存前768个字段, 剩下的保存在 Off page 中. 1个page至少保存2条行记录, B+tree 要求\nVARCHAR 类型字段最长 65535 字节, UTF-8 字符集下 VARCHAR 最长 65535 / 3 = 21845\nCompressed, Dynamic 对应行溢出数据, 只保存20个字节的指针, 指向实际数据存放的 Off Page 中, Compressed会用zlib对 BLOB, TEXT, VARCHAR 这类大长度类型的数据进行压缩\n","id":6,"section":"posts","summary":"\u003cp\u003e学习记录 InnoDB 表相关内容\u003c/p\u003e","tags":["MySQL"],"title":"MySQL 之 InnoDB . 表","uri":"https://www.luyang.ink/2016/09/mysql-innodb-table/","year":"2016"},{"content":"InnoDB 存储引擎支持事务, 其设计目的主要面向在线事务处理(OLTP)的应用. 其特点是行锁, 外键, 非锁定读等, MySQL在5.5.8版本后将其设为默认存储引擎.\n体系结构 InnoDB 存储引擎架构由 内存中(in-memory) 和 磁盘上(on-disk) 2部分结构组成\n图片中是 MySQL 5.7 中 InnoDB 的体系结构\nin-memory 结构 缓冲池 Buffer Pool 缓冲池是主内存中的一个区域, InnoDB在访问表和索引数据时会在其中进行缓存, 用来减轻CPU速度与磁盘速度的差异, 提高数据库的整体性能. 在专用服务器上, 通常将多达80％的物理内存分配给缓冲池.\n缓冲池被分成一个一个的page, 每个page可以存储多条rows. 缓冲池用List来管理这些page, 使用LRU算法变体淘汰最近很少使用的数据, 如下图:\n New Sublist: 最近访问的pages, 在 List 的 Head Old Sublist: 最近很少访问的pages, 在 List 的 Tail  Old Sublist 占用 3/8 的空间, 以 New Sublist 的 Tail 与其 Head 做 midpoint\nInnoDB 将读取的数据放入缓冲池时, 先将其放在 midpoint(old sublist 的 head), 这样操作可以防止一些数据库的操作, 例如:mysqldump命令, 将 New Sublist 中的热点数据刷掉\n可以通过 SHOW ENGINE INNODB STATUS 查看 InnoDB 相关信息\n---------------------- BUFFER POOL AND MEMORY ---------------------- Total large memory allocated 2198863872 Dictionary memory allocated 776332 Buffer pool size 131072 Free buffers 124908 Database pages 5720 Old database pages 2071 Modified db pages 910 Pending reads 0 Pending writes: LRU 0, flush list 0, single page 0 Pages made young 4, not young 0 0.10 youngs/s, 0.00 non-youngs/s Pages read 197, created 5523, written 5060 0.00 reads/s, 190.89 creates/s, 244.94 writes/s Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s LRU len: 5720, unzip_LRU len: 0 I/O sum[0]:cur[0], unzip sum[0]:cur[0]  变更缓冲区 Change Buffer 变更缓冲区中有 Insert Buffer, Update Buffer, Delete Buffer\n由于二级索引(secondary index)的插入/更新/删除操作不是每一次都直接插入到索引页中, 而是先判断该页是否在缓冲池中, 若在, 则直接操作; 若不在, 则跟根据操作放到对应的 Buffer 中, 之后再周期性的将其merge后加载到 buffer pool 中\n自适应Hash索引 Adaptive Hash Index InnoDB 会根据数据访问的频率和模式来自动的为某些热点数据建立Hash索引, 这是数据库自优化的(self-tuning), 无需人为干涉\n日志缓冲区 Log Buffer 日志缓冲区保存要写入磁盘上的日志文件的数据. 增大 Log Buffer, 可以让Update, Delete操作大量数据的事物正常进行\n","id":7,"section":"posts","summary":"\u003cp\u003eInnoDB 存储引擎支持事务, 其设计目的主要面向在线事务处理(OLTP)的应用. 其特点是行锁, 外键, 非锁定读等, MySQL在5.5.8版本后将其设为默认存储引擎.\u003c/p\u003e","tags":["MySQL"],"title":"MySQL 之 InnoDB . 初见","uri":"https://www.luyang.ink/2016/08/mysql-innodb/","year":"2016"},{"content":"由于国情, homebrew update/install非常缓慢, 还是不是遇到链接超时问题. 虽然可以缓存国内的源, 更新是快了, 不过下载还是鸟样, 治标不治本\n如果有自己的机场, 可以让终端命令走代理\n# 当前终端会话 export ALL_PROXY=socks5://127.0.0.1:1080  如果想长久生效\n#bash echo export ALL_PROXY=socks5://127.0.0.1:1080 \u0026gt;\u0026gt; ~/.bash_profile #zsh echo export ALL_PROXY=socks5://127.0.0.1:1080 \u0026gt;\u0026gt; ~/.zsh_profile  这样homebrew每次update/install都可以通过代理来进行了\n 注意: 部分终端命令也会通过该代理, 如果遇到网络的问题, 优先要想到原因可能是代理\n","id":8,"section":"posts","summary":"\u003cp\u003e由于国情, homebrew update/install非常缓慢, 还是不是遇到链接超时问题. 虽然可以缓存国内的源, 更新是快了,\n不过下载还是鸟样, 治标不治本\u003c/p\u003e","tags":["Homebrew"],"title":"Homebrew设置代理","uri":"https://www.luyang.ink/2016/07/homebrew-proxy/","year":"2016"},{"content":"记录一下 Go 语言中的函数、方法和接口\n数组 固定长度的特定类型元素组成, 可以有0个或多个元素组成. 长度必须是常量表达式, 因为其长度需要在编译阶段确定.\nvar a [3]int // 长度=3的int数组, 元素值=0 var b = []int{1, 2, 3} // 长度=3, 元素值=1,2,3 var c = []int{2: 3, 1: 2} // 长度=3, 元素值=0,2,3 var d = []int{1, 2, 4: 5, 6} // 长度=3, 元素值=1,2,0,0,5,6 // [3]int和[4]int是2种不同的数组类型 var q = [3]int{1, 2, 3} q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int  一个数组变量即表示整个数组, 并不是隐式的指向第一个元素的指针(比如C语音数组), 而是一个完整的值. 数值变量被赋值或传递时, 会 copy 整个数组, 较大数组可以传递一个指向数值的指针, 数组指针!=数组\nvar a = []int{1, 2, 3} // a是1个数组 var b = \u0026amp;a // b是指向a数组的指针 fmt.Println(a, a[1]) // 打印数组第2个元素 fmt.Println(*b, (*b)[1]) // 通过数组指针访问数组第2个元素 for _, v := range *b { // 通过数组指针迭代数组元素 fmt.Println(v) }  字符串 字符串是一个不可改变的字节序列, 字符串的元素不可修改, 是一个之都的字节数组, 长度也是固定的.\nGo语言字符串底层结构定义:\ntype StringHeader struct { Data uintptr Len int }  \u0026ldquo;Hello, world\u0026rdquo; 字符串底层数据布局, 和数组一致：\n采用 UTF-8 编码.\nfmt.Printf(\u0026quot;%#v\\n\u0026quot;, []byte(\u0026quot;Hello, 世界\u0026quot;)) // output: // []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c}  \u0026ldquo;Hello, 世界\u0026rdquo; 字符串内存结构布局\nfmt.Printf(\u0026quot;%#v\\n\u0026quot;, []rune(\u0026quot;世界\u0026quot;)) // output: []int32{19990, 30028} fmt.Printf(\u0026quot;%#v\\n\u0026quot;, string([]rune{'世', '界'})) // output: 世界  []rune 用于表示每个 Unicode 码点, []int32 别名\n字符串的强制类型转换主要涉及到 []byte 和 []rune 两种类型. 每个转换都可能隐含重新分配内存的代价, 最坏的情况下运算时间复杂度都是O(n).\nslice 切片 简化版动态数组, 结构定义如下:\ntype SliceHeader struct { Data uintptr Len int Cat int // 容量 } var x = []int{2, 3, 5, 7, 11} var y = x[1:3]  切片内存布局\n切片定义方式\nvar a = []int // nil切片, =nil, 表示不存在的切片 var b = []int{} // 空切片, !=nil, 表示空集合 var c = []int{1, 2, 3} // 3个元素的切片, len=cap=3 var d = c[:2] // 2个元素的切片, len=2, cap=3 var e = c[0:2:cap(c)] // 2个元素切片, len=2, cap=3 var f = c[:0] // 0个元素切片, len=0, cap=3 var g = make([]int, 3) // 3个元素切片, len=cap=3 var h = make([]int, 2, 3) // 2个元素切片, len=2, cap=3 var i = make([]int, 0, 3) // 0个元素切片, len=0, cap=3  len返回有效元素的长度, cap返回切片容量\n添加切片元素 append 可以再切片末尾追加 N 个元素, 在容量不足时, 会导致重新分配内存\n// 尾部追加 var a[]int a = append(a, 1) // 添加1个元素 a = append(a, 1, 2, 3) // 添加多个元素 a = append(a, []int{1, 2, 3}) // 添加一个切片, 切片需要解包 // 开头添加, 会导致内存重新分配 var a[]int{1, 2, 3} a = append([]int{0}, a...) // 开通添加1个元素 a = append([]int{-3, -2, -1}, a...) // 开通添加1个切片 // 中间添加 var a[]int a = append(a[:i], append([]int{x}, a[i:]...)...) // 在位置i插入x a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片 // 中间添加 a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置  删除切片元素 删除元素分为: 从开头删除, 从中间位置删除, 从尾部删除\na = []int{1, 2, 3} // 尾部删除 a = a[:len(a)-1] // 删除尾部1个元素 a = a[:len(a)-N] // 删除尾部N个元素 // 开头删除 a = [1:] // 删除开头1个元素 a = [N:] // 删除开头N个元素 a = append(a[:0], a[1:]...) // 删除开头1个元素 a = append(a[:0], a[N:]...) // 删除开头N个元素 a = a[:copy(a, a[1:])] //删除开头1个元素 a = a[:copy(a, a[N:])] //删除开头N个元素 // 中间删除 a = append(a[:i], a[i+1:]...) // 删除中间1个元素 a = append(a[:i], a[i+N:]...) // 删除中间N个元素 a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素 a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素  函数","id":9,"section":"posts","summary":"\u003cp\u003e记录一下 Go 语言中的函数、方法和接口\u003c/p\u003e","tags":["Go"],"title":"Go 语言基础 . 函数、方法和接口","uri":"https://www.luyang.ink/2016/04/go-basic-func-method-interface/","year":"2016"},{"content":"记录一下 Go 语言中的数据结构 . 数组、字符串和切片\n数组 固定长度的特定类型元素组成, 可以有0个或多个元素组成. 长度必须是常量表达式, 因为其长度需要在编译阶段确定.\nvar a [3]int // 长度=3的int数组, 元素值=0 var b = []int{1, 2, 3} // 长度=3, 元素值=1,2,3 var c = []int{2: 3, 1: 2} // 长度=3, 元素值=0,2,3 var d = []int{1, 2, 4: 5, 6} // 长度=3, 元素值=1,2,0,0,5,6 // [3]int和[4]int是2种不同的数组类型 var q = [3]int{1, 2, 3} q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int  一个数组变量即表示整个数组, 并不是隐式的指向第一个元素的指针(比如C语音数组), 而是一个完整的值. 数值变量被赋值或传递时, 会 copy 整个数组, 较大数组可以传递一个指向数值的指针, 数组指针!=数组\nvar a = []int{1, 2, 3} // a是1个数组 var b = \u0026amp;a // b是指向a数组的指针 fmt.Println(a, a[1]) // 打印数组第2个元素 fmt.Println(*b, (*b)[1]) // 通过数组指针访问数组第2个元素 for _, v := range *b { // 通过数组指针迭代数组元素 fmt.Println(v) }  字符串 字符串是一个不可改变的字节序列, 字符串的元素不可修改, 是一个之都的字节数组, 长度也是固定的.\nGo语言字符串底层结构定义:\ntype StringHeader struct { Data uintptr Len int }  \u0026ldquo;Hello, world\u0026rdquo; 字符串底层数据布局, 和数组一致：\n采用 UTF-8 编码.\nfmt.Printf(\u0026quot;%#v\\n\u0026quot;, []byte(\u0026quot;Hello, 世界\u0026quot;)) // output: // []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c}  \u0026ldquo;Hello, 世界\u0026rdquo; 字符串内存结构布局\nfmt.Printf(\u0026quot;%#v\\n\u0026quot;, []rune(\u0026quot;世界\u0026quot;)) // output: []int32{19990, 30028} fmt.Printf(\u0026quot;%#v\\n\u0026quot;, string([]rune{'世', '界'})) // output: 世界  []rune 用于表示每个 Unicode 码点, []int32 别名\n字符串的强制类型转换主要涉及到 []byte 和 []rune 两种类型. 每个转换都可能隐含重新分配内存的代价, 最坏的情况下运算时间复杂度都是O(n).\nslice 切片 简化版动态数组, 结构定义如下:\ntype SliceHeader struct { Data uintptr Len int Cat int // 容量 } var x = []int{2, 3, 5, 7, 11} var y = x[1:3]  切片内存布局\n切片定义方式\nvar a = []int // nil切片, =nil, 表示不存在的切片 var b = []int{} // 空切片, !=nil, 表示空集合 var c = []int{1, 2, 3} // 3个元素的切片, len=cap=3 var d = c[:2] // 2个元素的切片, len=2, cap=3 var e = c[0:2:cap(c)] // 2个元素切片, len=2, cap=3 var f = c[:0] // 0个元素切片, len=0, cap=3 var g = make([]int, 3) // 3个元素切片, len=cap=3 var h = make([]int, 2, 3) // 2个元素切片, len=2, cap=3 var i = make([]int, 0, 3) // 0个元素切片, len=0, cap=3  len返回有效元素的长度, cap返回切片容量\n添加切片元素 append 可以再切片末尾追加 N 个元素, 在容量不足时, 会导致重新分配内存\n// 尾部追加 var a[]int a = append(a, 1) // 添加1个元素 a = append(a, 1, 2, 3) // 添加多个元素 a = append(a, []int{1, 2, 3}) // 添加一个切片, 切片需要解包 // 开头添加, 会导致内存重新分配 var a[]int{1, 2, 3} a = append([]int{0}, a...) // 开通添加1个元素 a = append([]int{-3, -2, -1}, a...) // 开通添加1个切片 // 中间添加 var a[]int a = append(a[:i], append([]int{x}, a[i:]...)...) // 在位置i插入x a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片 // 中间添加 a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置  删除切片元素 删除元素分为: 从开头删除, 从中间位置删除, 从尾部删除\na = []int{1, 2, 3} // 尾部删除 a = a[:len(a)-1] // 删除尾部1个元素 a = a[:len(a)-N] // 删除尾部N个元素 // 开头删除 a = [1:] // 删除开头1个元素 a = [N:] // 删除开头N个元素 a = append(a[:0], a[1:]...) // 删除开头1个元素 a = append(a[:0], a[N:]...) // 删除开头N个元素 a = a[:copy(a, a[1:])] //删除开头1个元素 a = a[:copy(a, a[N:])] //删除开头N个元素 // 中间删除 a = append(a[:i], a[i+1:]...) // 删除中间1个元素 a = append(a[:i], a[i+N:]...) // 删除中间N个元素 a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素 a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素  函数","id":10,"section":"posts","summary":"\u003cp\u003e记录一下 Go 语言中的数据结构 . 数组、字符串和切片\u003c/p\u003e","tags":["Go"],"title":"Go 语言基础 . 数组、字符串和切片","uri":"https://www.luyang.ink/2016/04/go-basic-array-string-slice/","year":"2016"},{"content":"\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 内存管理\nmalloc(), calloc() 分配一块新的内存\nrealloc() 调整已分配内存块大小\nfree() 释放已分配内存\nAllocating Memory Dynamically  void *malloc( size_t size );\n 分配一块至少 size 大小的内存块, 其内容是未确定的\n void *calloc( size_t count, size_t size );\n 分配一块至少 size * coount 大小的内存块, 换句话说, 可以有足够的空间装下 array 每个 size 大小的 element, 其内容初始化为0\n2个函数返回 void 指针也叫 typeleff pointer(无类型指针). 指针的值为分配内存的第一个byte的地址, 失败返回 null pointer\n如果将 void pointer 分配给其他类型的 pointer, compiler会隐式的将 void pointer 转换成合适的类型, 也可以显式的进行类型转换. pointer 什么类型, 访问内存内容就是什么类型\n#include \u0026lt;stdlib.h\u0026gt; // Provides function prototypes typedef struct { long key; } Record; // A structure type float *myFunc( size_t n ) { // Reserve storage for an object of type double double *dPtr = malloc( sizeof(double) ); if ( dptr == NULL ) { // Insufficient memory return NULL; } else { // Got the memory: use it *dPtr = 0.07; } }  calloc()在需要将申请的内存块初始化为0时很有用, 虽然速度会慢点\n// Get storage for an object of type double double *dPtr = calloc( 1, sizeof( double ) ); // Get storage for two objects of type Record Record *rPtr; if ( ( rPtr = calloc( 2, sizeof(Record) ) == NULL ) { /* Handle the insufficient-memory error ... */ } // Get storage for an array of n elements of type float float *fPtr = calloc( n, sizeof(float));  Characteristics of Allocated Memory 一块申请成功的内存块有一个指向其开始地址的 pointer, 该内存是对齐的\n已分配内存的 lifetime 为, 从开始分配到释放, 或是程序结束\nResizing and Releasing Memory 已分配的内存不在需要可以还给操作系统, 也可以通过调用 realloc() 增加或减少其大小\n void free( void *ptr ):\n 释放 ptr 指向开始地址的动态分配的内存块, null pointer 也可以, 只不过没啥影响\n *void realloc( void *ptr, size_t size );\n 释放 ptr 指向的内存块同时申请一块新的大小为 size 的内存块, 返回其内存地址, 该新地址可能与 ptr 相同. 会保留原内存块中的内容, 或是将原始内容 copy 到新内存块中. 如果新内存块比旧内存块大, 额外的 byte 内容未指定\n可以传递一个 null pointer, 这样类似于 malloc()\n不能分配一块指定大小的内存块, 返回一个 null pointer, 不会释放原内存块或修改它的内容\n传递给 free() 和 realloc() 的参数, 如果不是一个 null pointer, 必须是一个指向一块动态分配的内存开始地址的 pointer并且该内存块没有被 free 过. 否则程序行为未定义\n内存管理函数维护每块分配内存的信息, 这也就是 free() 和 realloc() 只需要一个 pointer. 也无需判断 free() 是否调用成功, 因为它没有返回值\nAn All-Purpose Binary Tree 动态分配内存是实现动态数据结构的基础, 例如 linked list, tree\nbinary search tree(BST) 二叉搜索树, 按照节点值排放每个节点, 在查找数据时可以运用二分查找算法 binary search algorithm\nCharacteristics 二叉树由一些数据 node 组成, 结构特点:\n 每个 node 最多有2个直接子节点 有一个 node 是 tree 的根节点, 成为 root, 没有父节点, 其他节点都有一个父节点 node 的排放根据如下规则: 节点的值大于或等于其左分支后代节点的值, 小余或等于其右分钟后代节点的值   没有子节点的节点称作 leaf (叶子节点), 每一个 node 都可以与其后代节点组成一个 subtree(子树), 该 node 为该 subtree 的 root 节点\n二叉树一个重要的属性 height, 从 root 到 leaf 最长 path. 也就是 该 path 经过的 node 数量, 不包括 root. 只有一个 root node 的 tree, 其 height 为0\nImplementation BSTree.h\ntypedef const void *GetKeyFunc_t( const void *dData ); typedef int CmpFunc_t( const void *pKey1, const void *pKey2 ); typedef struct Node { struct Node *left, *right; size_t size; char data[]; } Node_t; typedef struct { struct Node *pRoot; CmpFunc_t *cmp; GetKeyFunc_t *getKey; } BST_t; // 初始化 BST BST_t *newBST( CmpFunc_t *cmp, GetKeyFunc_t *getKey); // 插入一个节点 _Bool BST_insert(BST_t *pBST, const void *pData, size_t size); // 搜索 const void *BST_search(BST_t *pBst, const void *pKey); // 删除一个节点 _Bool BST_erase(BST_t *pBST, const void *pKey); // 清空树 void BST_clear(BST_t *pBST); // 树的遍历顺序 // 中序 int BST_inorder(BST_t *pBst, _Bool (*action)(void *pData)); int BST_rev_inorder(BST_t *pBst, _Bool (*action)(void *pData)); // 前序 int BST_preorder(BST_t *pBST, __Bool (*action)(void *pData)); // 后序 int BST_postorder(BST_t *pBST, _Bool (*action)(void *pData));  Generationg an Empty Tree 创建一个新的 BST\nconst void *defaultGetKey(const void *pData) { return pData; } BST_t *newBST(CmpFunc_t *cmp, GetKeyFunc_t *getKey) { BST_t *pBST = NULL; if (cmp != NULL) { pBST = malloc(sizeof(BST_t)); } if (pBST != NULL) { pBST-\u0026gt;pRoot = NULL; pBST-\u0026gt;cmp = cmp; pBST-\u0026gt;getKey = (getKey != NULL) ? getKey : defaultGetKey; } return pBST; }  Inserting New Data 插入新数据\nstatic _Bool insert(BST_t *pBST, Node_t **ppNode, const void *pData, size_t size); _Bool BST_insert(BST_t *pBST, const void *pData, size_t size) { if (pBST == NULL || pData == NULL || size == 0) { return false; } return insert(pBST, \u0026amp;(pBST-\u0026gt;pRoot), pData, size); } static _Bool insert(BST_t *pBST, Node_t **ppNode, const void *pData, size_t size) { Node_t *pNode = *ppNode; // Pointer to the root node of the subtree to insert the new node in. if (pNode == NULL) { pNode = malloc(sizeof(Node_t) + size); if (pNode != NULL) { // Thers is a place for a new leaf here. pNode-\u0026gt;left = pNode-\u0026gt;right = NULL; // Initialize the new node's members memcpy(pNode-\u0026gt;data, pData, size); *ppNode = pNode; return true; } else { return false; } } else { const void *key1 = pBST-\u0026gt;getKey(pData), *key2 = pBST-\u0026gt;getKey(pNode-\u0026gt;data); if (pBST-\u0026gt;cmp(key1, key2) \u0026lt; 0) { // in the left subtree return insert(pBST, \u0026amp;(pNode-\u0026gt;left), pData, size); } else { // in the right subtree return insert(pBST, \u0026amp;(pNode-\u0026gt;right), pData, size); } }  Finding Data in the Tree binary search algorithm(二分查找)来查找数据\nstatic const void *search(BST_t *pBST, const Node_t *pNode, const void *pKey); const void *BST_search(BST_t *pBST, const void *pKey) { if (pBST == NULL || pKey == NULL) { return NULL; } return search(pBST, pBST-\u0026gt;pRoot, pKey); // Start at the root of the tree } static const void *search(BST_t *pBST, const Node_t *pNode, const void *pKey) { if (pNode == NULL) { return NULL; } else { // Compare data int cmp_res = pBST-\u0026gt;cmp(pKey, pBST-\u0026gt;getKey(pNode-\u0026gt;data)); if (cmp_res == 0) { // Found a match return pNode-\u0026gt;data; } else if (cmp_res \u0026lt; 0) { // Continue the search in the left subtree return search(pBST, pNode-\u0026gt;left, pKey); } else { // or in the right subtree return search(pBST, pNode-\u0026gt;right, pKey); } } }  Removing Data from the Tree static Node_t *detachMin(Node_t **ppNode) { Node_t *pNode = *ppNode; // A pointer to the current node if (pNode == NULL) { return NULL; } else if (pNode-\u0026gt;left != NULL) { return detachMin( \u0026amp;(pNode-\u0026gt;left) ); // The minimum is in the left subtree } else { *ppNode = pNode-\u0026gt;right; // pNode points to the minimum node return pNode; // Attach the right child to the parent } } static _Bool erase(BST_t *pBsT, Node_t **ppNode, const void *pKey); _Bool BST_erase(BST_t *pBST, const void *pKey) { if (pBST == NULL || pKey == NULL) { return false; } return erase(pBST, \u0026amp;(pBST-\u0026gt;pRoot), pKey); // Start at the root of the tree } static _Bool erase(BST_t *pBST, Node_t **ppNode, const void *pKey) { Node_t *pNode = *ppNode; // Pointer to the current node if (pNode == NULL) { return false; } int cmp_res = pBST-\u0026gt;cmp(pKey, pBST-\u0026gt;getKey(pNode-\u0026gt;data)); if (cmp_res \u0026lt; 0) { return erase(pBst, \u0026amp;(pNode-\u0026gt;left), pKey); } else if (cmp_res \u0026gt; 0) { return erase(pBst, \u0026amp;(pNode-\u0026gt;right), pKey); } else { // Found the node to be deleted if (pNode-\u0026gt;left == NULL) { // If no more than one child *ppNode = pNode-\u0026gt;right; // attach the child to the parent } else if (pNode-\u0026gt;right == NULL) { *ppNode = pNode-\u0026gt;left; } else { // Graft is onto the deleted node's parent Node_t *pMin = detachMin(\u0026amp;(pNode-\u0026gt;right)); *ppNode = pMin; pMin-\u0026gt;left = pNode-\u0026gt;left; pMin-\u0026gt;right = pNode-\u0026gt;right; } free(pNode); return true; } } static void clear(NOde_t *pNode); void BST_clear(BST_t *pBST) { if (pBST != NULL) { clear(pBST-\u0026gt;root); pBST-\u0026gt;pRoot = NULL; } } static void clear(Node_t *pNode) { if (pNode != NULL) { clear(pNode-\u0026gt;left); clear(pNode-\u0026gt;right); free(pNode); } }  Traversiong a Tree L = left subtree, R = right subtree, N = node itself\n  In-order or LNR traversal left subtree =\u0026gt; node itself =\u0026gt; right subtree\n  Pre-order or NLR traversal node itself =\u0026gt; left subtree =\u0026gt; right subtree\n  Post-order or LRN traversal left subtree =\u0026gt; right subtree =\u0026gt; node itself\n  static int inorder(Node_t *pNode, _Bool (*action)(void *pData)); int BST_inorder(BST_t *pNST, _Bool (*action)(void *pData)) { if (pBST == NULL || action == NULL) { return 0; } else { return inorder(pBST-\u0026gt;Root, action); } } static int inorder(Node_t *pNode, _Bool (*action)(void *pData)) { int count = 0; if (pNode == NULL) { return 0; } count = inorder(pNode-\u0026gt;left, action); // L: Traverse the left tree if (action(pNode-\u0026gt;data)) { // N: Visit the current node itself ++count; } count += inorder(pNode-\u0026gt;right, action); // R: Traverse the right subtree } ","id":11,"section":"posts","summary":"\u003cp\u003e\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 内存管理\u003c/p\u003e","tags":["C"],"title":"Dynamic Memory Management","uri":"https://www.luyang.ink/2016/04/dynamic-memory-management/","year":"2016"},{"content":"\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 输入输出\nStreams Streams: 所有输入输出文件或设备不管读写一个字或一个byte, 或是文本行, 给定大小的数据块, 在 C 中可以是 test streams, 也可以是 binary streams\n当多个 thread 访问同一个 Streams 时, I/O 库中的 function 都有一个exclusive lock独占锁, 防止 data race\nText Streams 文本流会将文本字符按行分割. 以换行符结尾, 可以为空行也就是只包含换行符一个字符\n非 unix-based 系统会自动转换换行符, windows 系统换行符为 \\r\\n, ^Z 代表结尾\nBinary Streams 二进制流是一段没有任何修改的byte流, I/O function 在操作二进制流时不会对任何控制符进行解析\nFILES 通过 fopen() function 打开的文件会初始化一个 FILE type 的流, 包含一个指向该文件所使用的 buffer 的指针, 文件内未知指示符, error 和 EOF 的 flag\nFile Position 正常读写一个文件 position 会指向文件开始, 追加方式打开一个文件, position 会指向文件末尾. fseek(), fsetpos(), rewind()可以用于随机读random file access\nBuffers 读写一个字符效率不高, 因此一个 stream 会有一块 buffer 对文件进行一块一块的传输\nFully Buffered buffer 空间满的时候才进行传输\nLine-buffered 遇到换行符时或 buffer 空间已满进行传输\nUnbuffer 尽可能及时的传输\n可以通过 fflush() 显示的从 buffer 到 file 进行传输. 当关闭 stream 时, buffer 也会 flush 到文件, 程序终止后所有相关的 stream 的 buffer 也都会 flush 到文件\nfopen() 打开的文件是 fully buffered, 交互设备是 line-buffered\n之前 input 或 output 前, 可以通过 setbuf(), setvbuf() 修改 buffer mode\nThe Standard Streams Opening and Closing Files Opening a File FILE *fopen(const char * restrict filename, const char * restrict mode); FILE *freopen(const char * restrict filename, const char * restrict mode, FILE * restrict stream); // 用来重定向 stdin, stdout, stderr FILE *tmpfile(void); // 创建一个唯一的临时文件  Reading and Writing Byte-Oriented and Wide-Oriented Streams 文件有个方向(orientation), 打开文件的时候未知, 首次访问时, 如果通过 byte-character I/O function 访问, 那就是 byte-oriented, 如果通过 wide-character I/O function 访问, 那就是 wide-oriented. 当程序启动时 stdin, stdout, stderr的 orientation 也是未定义的\n可以通过 fwide() 来查看和设置 stream 的 orientation\nError Handling 通过 return value, error, EOF, global errno 判断是否发生错误\nReturn values and status flags // ferror (void) fputc('*', fp); // Write an asterisk to the stream fp if (ferror(fp)) { fprintf(stderr, \u0026quot;Error writing\\n\u0026quot;); } // EOF, WEOF int i, c; char buffer[1024]; i = 0; while (i \u0026lt; 1024 \u0026amp;\u0026amp; (c = fgetc(fp)) != EOF) { buffer[i++] = (char) c; } if (i \u0026lt; 1024 \u0026amp;\u0026amp; !feof(fp)) { fprintf(stderr, \u0026quot;Error reading.\\N\u0026quot;); }  The error variable errno ftell(), fgetpos(), fsetpos() 发生错误时会通过设置 global errno, 通过 perror() 可以打印 errno 代表的错误信息\nlong pos = ftell(fp); // Get the current file position if (pos \u0026lt; 0L) { // ftell(0 returns -1L if an error occurs perror(\u0026quot;ftell()\u0026quot;); // output: ftell(): Bad file descriptor }  Unformatted I/O Reading characters int fgetc(FILE *fp); int getc(FILE *fp); int getchar(void); wint_t fgetwc(FILE *fp); wint_t getwc(FILE *fp); wint_t getwchar(void);  Putting a character back int ungetc(intc, FILE *fp); wint_t ungetwc(wint_t c, FILE *fp);  Writing characters int fputc(int c, FILE *fp); int putc(int c, FILE *fp); int putchar(int c); wint_t fputwc(wchar_t wc, FILE *fp); wint_t putwc(wchar_t wc, FILE *fp); wint_t putwchar(wchar_t wc);  Reading strings n - 1 characters, append a null character to terminate the string\nchar *fgets(char *buf, int n, FILE *fp); wchar_t *fgetws(wchar_t *buf, int n, FILE *fp); char *gets(char *buf); // Obsolete char *gets_s(char *buf, size_t n); // C11  Writing strings a null-terminated string to a stream\nint fputs(const char *s, FILE *fp); int puts(const char *s); int fputws(const wchar_t *s, FILE *fp);  这3个函数共同点已经差异:\n  fputs(), fputws() 将 fp 指向的 string 写入到 output stream, 处理结尾的 null character\n  puts() 将字符串紧跟着一个 newline character写入到 stdout stream, 没有对应wide-character的 puts()函数\n  如果出错返回 EOF, 非负数代表成功\n  Reading and writing blocks size_t fread(void *buffer, size_t size, size_t n, FILE *fp); size_t fwrite(const void *buffer, size_t size, size_t n, FILE *fp);  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define ARRAY_LEN 100 // Maximum number of records in the buffer // A structure type for the records typedef struct { long key; char name[32]; } Record_t; char inFile[] = \u0026quot;records.dat\u0026quot;, outFile[] = \u0026quot;packed.dat\u0026quot;; // Terminate the program with an error message static inline void error_exit(int status, const char *error_msg) { fputs(error_msg, stderr); exit(status); } int main() { FILE *fpIn, *fpOut; Record_t record, *pArray; unsigned int i; if ((fpIn = fopen(inFile, \u0026quot;rb\u0026quot;)) == NULL) { error_exit(1, \u0026quot;Error on opening input file\u0026quot;); } else if ((fpOut = fopen(outFile, \u0026quot;wb\u0026quot;)) == NULL) { error_exit(2, \u0026quot;Error on opening output file\u0026quot;); } else { if ((pArray = malloc(ARRAY_LEN * sizeof(Record_t))) == NULL) { error_exit(3, \u0026quot;Insufficient memory\u0026quot;); } i = 0; // Read one record at a time while (fread(\u0026amp;record, sizeof(Record_t), 1, fpIn) == 1) { if (record.key != 0L) { // If not marked as deleted pArray[i++] = record; // then copy the record if (i == ARRAY_LEN) { // Buffer full? if (fwrite(pArray, sizeof(Record_t), i, fpOut) \u0026lt; i) { break; } i = 0; } } } } if (i \u0026gt; 0 \u0026amp;\u0026amp; !ferror(fpOut)) { // Write the remain records fwrite(pArray, sizeof(Record_t), i, fpOut); } // Handle errors if (ferror(fpOut)) { error_exit(4, \u0026quot;Error on writing to output file\u0026quot;); } else if (ferror(fpIn)) { error_exit(5, \u0026quot;Error on reading input file\u0026quot;); } return 0; }  Formatted Output The printf() function family // Writes to stdout int printf(const char *restrict format, ...); // Writes to FILE * fp int fprintf(FILE * restrict fp, const char * restrict format, ...); // Writes to char * buf, 易越界 int sprintf(char * restrict buf, const char * restrict format, ...); int snprintf(char * restrict buf, size_t n, const char * restrict format, va_list argptr);  Formatted Input The scanf() function family // Reads from stdin int scahf(const char * restrict format, ...); // Reads from FILE fp int fscanf(FILE * restrict fp, const char * restrict format, ...); // Reads from the char array src int sscanf(const char * restrict src, const char * restrict format, ...);  Random File Access 可以直接读取或修改给定文件任意未知的内容\nObtaining the Currrent File Position // return FILE *fp file position long ftell(FILE *fp); int fgetpos(FILE * restrict fp, fpos_t * restrict ppos);  Setting the File Access Position int fsetpos(FILE *fp, const fpos_t *ppos); int fseek(FILE *fp, long offset, int origin); ","id":12,"section":"posts","summary":"\u003cp\u003e\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 输入输出\u003c/p\u003e","tags":["C"],"title":"Input and Output","uri":"https://www.luyang.ink/2016/04/input-and-output/","year":"2016"},{"content":"\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 多线程\nThreads 当启动一个程序, 操作系统会为程序创建一个进程来运行它. 一个进程由一个或多个线程组成. 每个线程都是进程执行指令中的一部分\n系统调度器分配给每个运行的线程的 CUP 时间是均等的. 一般 CUP 是抢占式(preemptive)的, 它会中断正在被某个CUP执行的 thread, 同时分配给其不同的一个 thread 执行. 即使在一个 CPU 的系统中, 用户都会感到程序是在并行执行的, 事实上在多个 CPU 系统中, 多个 thread 才能同时执行\n每个进程在内存中都有自己的内存地址, 并且还有一些专有的资源, 例如打开的文件. 进程内部的 thread 贡献这些资源. 通常进程中的多个thread 贡献同样的地址空间. 这也使在进程中进行任务切换比不同的进程间简单\n每个 thread 在任务切换中也有自己的所需资源, 包括栈内存, CPU 寄存器. 方便内存处理自己的数据, thread 也会有 线程指定 的永久内存\n因为进程中的所有线程使用相同的地址空间, 贡献全局数据和静态数据. 意味这不同的 thread 可以并发访问相同的内存地址. 也就是容易发生 data race 或 race condition, 这就需要开发人员保证 thread 的数据同步\nCreating Threads int thrd_create(thrd_t *thr, thrd_start_t func, void *arg); int thrd_join(thrd_t thr, int *result); // detach int thrd_detach(thrdt thr);  #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;thread.h\u0026gt; #define MAX_THREADS 8 #define MIN_BLOCK_SIZE 100 typedef struct { float *start; // Start and length of the int len; // array block passed to parallel_sum() int block_size; // Size of the smallest blocks double sum; // The result } int parallel_sum(void *arg); // Prototype of the thread function // --------------------------------------------------------------- // Caculate the sum of array elements and write is to *sumPtr // sum() calls the function parallel_sum() for parallel processiong // Return value: true if no error occurs; otherwise, false bool sum(float arr[], int len, double* sumPtr) { int block_size = len / MAX_THREADS; if (block_size \u0026lt; MIN_BLOCK_SIZE) { block_size = len; } Sum_arg args = { arr, len, block_size, 0.0 }; if (parallel_sum(\u0026amp;args)) { *sumPtr = arg.sum; return true; } return false; } // --------------------------------------------------------------- // Recursive helper function to divide the work among several threads int parallel_sum(void *arg) { Sum_arg *argp = (Sum_arg*) arg; // A pointer to the arguments if (argp-\u0026gt;len \u0026lt;= argp-\u0026gt;block_size) { // If lenght \u0026lt;= block_size, add up the elements for (int = 0; i \u0026lt; argp-\u0026gt;len; i++) { argp-\u0026gt;sum += argp-\u0026gt;start[i]; } return 1; } else { int mid = argp-\u0026gt;len / 2; Sum_arg arg2 = { // Specifies second half argp-\u0026gt;start + mid, argp-\u0026gt;len - mid, argp-\u0026gt;block_size, 0 }; argp-\u0026gt;len = mid; // Length of first half thrd_t th; int res = 0; if (thrd_create(\u0026amp;th, parallel_sum, arg) != thrd_success) { return 0; } if (!parallel_sum(\u0026amp;arg2)) { // Process second half by recursion in the current thread thrd_detch(th); return 0; } thrd_join(th, \u0026amp;res); if (!res) { return 0; // Sibling thread reported failure } argp-\u0026gt;sum += arg2.sum; return 1; } }  Accessing Shared Data 如果多个 thread 访问相同的共享数据, 其中有一个 thread 修改了该数据, 为了防止 data race, 共享数据必须在其他 thread 中同步, 否则一个读的 thread 可以中断一个正在写的 thread, 因为程序执行时系统每次调度 thread 会不同\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;threads.h\u0026gt; #define COUNT 1000000L long counter = 0; void incFunc(void) { for (long i = 0; i \u0026lt; COUNT; ++i) { ++counter; } } void decFunc(void) { for (long i = 0; i \u0026lt; COUNT; ++i) { --counter; } } int main(void) { clock_t cl = clock(); thrd_t th1, th2; if (thrd_create(\u0026amp;th1, (thrd_start_t)incFunc, NULL) != thrd_success) { fprintf(stderr, \u0026quot;Error creating thread\\n\u0026quot;); return -1; } if (thrd_create(\u0026amp;th2, (thrd_start_t)incFunc, NULL) != thrd_success) { fprintf(stderr, \u0026quot;Error creating thread\\n\u0026quot;); return -1; } thrd_join(th1, NULL); thrd_join(th2, NULL); printf(\u0026quot;Counter: %ld \\t\u0026quot;, counter); printf(\u0026quot;CPU time: %ld ms\\n\u0026quot;, (clock() - cl) * 1000 / CLOCKS_PER_SEC); return 0; }  上述执行结果 counter 应该为 0 , 但是实际输出为\n Counter: -714573 CPU time: 59 ms  Mutual Exclusion Mutex 用来防止多个 thread 同时访问共享资源. mutex 是一个控制资源单独访问权限对象. 与 condition variables 一起可以扩展同步权限控制\n*int mtx_int(mtx_t mtx, int mutextype); 创建一个指定 mutextype 的 mutex, 成功后, *mtx 保存新 mutex 的 ID, 返回 thrd_success . mutextype包括 mtx_plain, mtx_timed, mtx_plain | mtx_recursive, mtx_timed | mtx_recursive\n*void destroy(mtx_t mtx);\n*int mtx_lock(mtx_t mtx); block thread 直到获取指定 mutex 的锁\n*int mtx_unlock(mtx_t mtx); release mutex 锁, 在 release 前必须拥有 mutex 的锁\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;threads.h\u0026gt; #define COUNT 1000000L long counter = 0; mtx_t mtx; // A mutex for access to counter void incFunc(void) { for (long i = 0; i \u0026lt; COUNT; ++i) { mtx_lock(\u0026amp;mtx); ++counter; mtx_unlock(\u0026amp;mtx); } } void decFunc(void) { for (long i = 0; i \u0026lt; COUNT; ++i) { mtx_lock(\u0026amp;mtx); --counter; mtx_unlock(\u0026amp;mtx); } } int main(void) { if (mtx_init(\u0026amp;mtx, mtx_plain) != thrd_success) { fprintf(stderr, \u0026quot;Error intializing the mutex.\\n\u0026quot;); return -1; } clock_t cl = clock(); thrd_t th1, th2; if (thrd_create(\u0026amp;th1, (thrd_start_t)incFunc, NULL) != thrd_success) { fprintf(stderr, \u0026quot;Error creating thread\\n\u0026quot;); return -1; } if (thrd_create(\u0026amp;th2, (thrd_start_t)incFunc, NULL) != thrd_success) { fprintf(stderr, \u0026quot;Error creating thread\\n\u0026quot;); return -1; } thrd_join(th1, NULL); thrd_join(th2, NULL); printf(\u0026quot;Counter: %ld \\t\u0026quot;, counter); printf(\u0026quot;CPU time: %ld ms\\n\u0026quot;, (clock() - cl) * 1000 / CLOCKS_PER_SEC); mtx_destroy(\u0026amp;mtx); return 0; }  Communication Between Threads: Condition Variables /* ------------------------------------------------ * buffer.h * Declarations for a thread-safe buffer */ #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;threads.h\u0026gt; typedef struct Buffer { int *data; // Pointer to the array of data size_t size, count; // Maximum and current numbers of elements size_t tip, tail; // tip = index of the next free spot mtx_t mtx; // A mutex and cnd_t cndPut, cndGet; // two condition variables } Buffer bool bufInit(Buffer *bufPtr, size_t size); void bufDestroy(Buffer *bufPtr); bool bufPut(Buffer *bufPtr, int data); bool bufGet(Buffer *bufPtr, int *dataPtr, int sec); /* ------------------------------------------------ * buffer.c * Definitions of functions operating on Buffer */ #include \u0026quot;buffer.h\u0026quot; #include \u0026lt;stdlib.h\u0026gt; // For malloc() and free() bool bufInit(Buffer *bufPtr, size_t size) { if ((bufPtr-\u0026gt;data = malloc(size * sizeof(int))) == NULL) { return false; } bufPtr-\u0026gt;size = size; bufPtr-\u0026gt;count = 0; bufPtr-\u0026gt;tip = bufPtr-\u0026gt;tail = 0; return mtx_init(\u0026amp;bufPtr-\u0026gt;mtx, mtx_plain) == thrd_success \u0026amp;\u0026amp; cnd_init(\u0026amp;bufPtr-\u0026gt;cndPut) == thrd_success \u0026amp;\u0026amp; cnd_init(\u0026amp;bufPtr-\u0026gt;cndGet) == thrd_success; } void bufDestroy(Buffer *bufPtr) { cnd_destroy(\u0026amp;bufPtr-\u0026gt;cndPut); cnd_destroy(\u0026amp;bufPtr-\u0026gt;cndGet); mtx_destroy(\u0026amp;bufPtr-\u0026gt;mtx); free(bufPtr-\u0026gt;data); } // Insert a new element in buffer bool bufPut(Buffer *bufPtr, int data) { mtx_lock(\u0026amp;bufPtr-\u0026gt;mtx); while (bufPtr-\u0026gt;count == bufPtr-\u0026gt;size) { if (cnd_wait(\u0026amp;bufPtr-\u0026gt;cndPut, \u0026amp;bufPtr-\u0026gt;mtx) != thrd_success) { return false; } } bufPtr-\u0026gt;data[bufPtr-\u0026gt;tip] = data; bufPtr-\u0026gt;tip = (bufPtr-\u0026gt;tip + 1) % bufPtr-\u0026gt;size; ++bufPtr-\u0026gt;count; mtx_unlock(\u0026amp;bufPtr-\u0026gt;mtx); cnd_signal(\u0026amp;bufPtr-\u0026gt;cndGet); return true; } // Remove an element from the buffer. If the buffer is empty, wait no more than sec seconds bool bufGet(Buffer *bufPtr, int *dataPtr, int sec) { struct timespec ts; timepec_get(\u0026amp;ts, TIME_UTC); // The current time + sec seconds delay ts.tv_sec += sec; mtx_lock(\u0026amp;bufPtr-\u0026gt;mtx); while (bufPtr-\u0026gt;count == 0) { if (cnd_timedwait(\u0026amp;bufPtr-\u0026gt;cndGet, \u0026amp;bufPtr-\u0026gt;mtx, \u0026amp;ts) != thrd_success) { return false; } } *dataPtr = bufPtr-\u0026gt;data[bufPtr-\u0026gt;tail]; bufPtr-\u0026gt;tail = (bufPtr-\u0026gt;tail + 1) % bufPtr-\u0026gt;size; --bufPtr-\u0026gt;count; mtx_unlock(\u0026amp;bufPtr-\u0026gt;mtx); cnd_signal(\u0026amp;bufPtr-\u0026gt;cndPut); return true; } // producer_comsumer.c #include \u0026quot;buffer.h\u0026quot; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NP 2 // Number of producers #define NC 3 // Number of comsumers struct Arg { // Arguments for the thread functions int id; Buffer *buffer; }; _Noreturn void errorExit(const char *msg) { fprintf(stderr, \u0026quot;%s\\n\u0026quot;, msg); exit(0xff); } int main(void) { printf(\u0026quot;producer-Consumer Demo\\n\\n\u0026quot;); Buffer buf; // Create a buffer fo five products bufInit(\u0026amp;buf, 5); thrd_t prod[NP], cons[NC]; // The threads and their arguments struct Arg proArg[NP], consArg[NC]; int i = 0, res = 0; for (i = 0; i \u0026lt; NP; ++i) { // Start the producers prodArg[i].id = i + 1; prodArg[i].bufPtr = \u0026amp;buf; if (thrd_create(\u0026amp;prod[1], producer, \u0026amp;prodArg[i]) != thrd_success) { errorExit(\u0026quot;Thread error.\u0026quot;); } } for (i = 0; i \u0026lt; NC; ++i ) { // Start the consumers. consArg[i].id = i+1, consArg[i].bufPtr = \u0026amp;buf;\u2028if (thrd_create(\u0026amp;cons[i], consumer, \u0026amp;consArg[i] ) != thrd_success) { errorExit(\u0026quot;Thread error.\u0026quot;); } } for (i = 0; i \u0026lt; NP; ++i) { thrd_join(prod[i], \u0026amp;res); printf(\u0026quot;\\nProducer %d ended with result %d.\\n\u0026quot;, prodArg[i].id, res); } for (i = 0; i \u0026lt; NC; ++i) { thrd_join(cons[i], \u0026amp;res); printf(\u0026quot;Consumer %d ended with result %d.\\n\u0026quot;, consArg[i].id, res); } bufDestroy(\u0026amp;buf); return 0; } int producer(void *arg) { // The producers' thread function struct Arg *argPtr = (struct Arg *) arg; int id = argPtr-\u0026gt;id; Buffer *bufPtr = argPtr-\u0026gt;bufPtr; int count = 0; for (int i = 0; i \u0026lt; 10; ++i) { int data = 10 * id + i; if (bufPut(bufPtr, data)) { printf(\u0026quot;Producer %d produced %d\\n\u0026quot;, id, data); ++count; } else { fprintf(stderr, \u0026quot;Producer %d: error storing %d\\n\u0026quot;, id, data); } } return count; } int consumer(void *arg) { // The consumers' thread function. struct Arg *argPtr = (struct Arg *) arg; int id = argPtr-\u0026gt;id; Buffer *bufPtr = argPtr-\u0026gt;bufPtr; int count = 0, data = 0; while (bufGet(bufPtr, \u0026amp;data, 2)) { ++count; printf(\u0026quot;Consumer %d consumed %d\\n\u0026quot;, id, data); } return count; } ","id":13,"section":"posts","summary":"\u003cp\u003e\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 多线程\u003c/p\u003e","tags":["C"],"title":"Multithreading","uri":"https://www.luyang.ink/2016/04/multithreading/","year":"2016"},{"content":"\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 声明\nDeclarations Storage Class Specifiers 存储类 变量与函数的可访问性(作用域范围)与生存期\n  auto 具有 automatic storage duration 性质. function 内部变量默认\n  register 提示 compiler 访问这个变量越快越好, 理想状态. 把变量存放在某个 CPU 寄存器中, 但是有时把 register 声明的变量当成普通的 auto 变量\n  static 具有内部链接. 变量是否有链接或内部链接依赖于该变量是定义在函数内部还是外部. 变量都具有 static storage duration 性质. 因此可以用来声明具有块作用域的局部变量\n  extern 具有外部链接. 可以在任何地方访问 extern 声明的函数和变量, 具有 static storage duration 性质\n  _Thread_local 没有 thread 都拥有自己单独的变量实例\n  Type Qualifiers 类型限定符   const 静态的, 程序此后不能修它\n  volatile 变量的值可能被其他程序或事件修改, volatile 告诉 compiler , 每次用到该变量时都有重新读取它的值, 即使没有被程序修改过. 常用在硬件接口, 一个值可以被外部事件修改, 避免 compiler 对此变量进行 cache, 造成数据不一致\n  restrict 只限定指针变量, 除了通过该指针不会被其他方式修改, compiler 可以用某种优化技术进行优化, 也可以再不影响结果的情况下忽略 restrict\n  _Atomit array 不能为 atomic\n  extern const volatile int ticks;  ticks 不能被程序本身修改, 但是可以通过别的方式修改, 例如: 时间中断处理程序\nconst int limit = 10000; // A constant int object typedef struct { double x, y, r; } Circle; // A structure type const Circle unit_circle = { 0, 0, 1 }; // A constant Circle object const floatv[] = { 1.0F, 0.5F, 0.25F }; // An array of constant float elements volatile short * restrict vsPtr; // A restricted pointer to volatile short  对应指针类型, 星号(*) 右侧的限定符只限定指针, 而星号(*)左侧的限定符用来限定指针指向的变量\nDeclarations and Definitions 申明和定义 凡是被多次声明的变量或函数，必须有且只有一个声明是定义，如果有多个定义，或者一个定义都没有，链接器就无法完成链接。\n标示符(identifier)的声明是定义的情况:\n 声明一个函数, 如果他包含函数体时  int iMax( int a, int b ); // This is a declaration, not a definition int iMax( int a, int b) { // This is the function's definition return ( a \u0026gt;=b ? a : b ); }   如果为变量分配了存储空间就是定义(difinition). 包含初始化的声明都是定义, 而且函数块内部的声明都是定义, 除非包含一个 extern 的 storage class specifier  int a = 10; // Definition of a extern double b[]; // Declaration of the array b, which is defined elsewhere in the program void func() { extern char c; // Declaration of c, not a definition static short d; // Definition of d float e; // Definition of e }  如果再所有函数外部申明一个没有初始化并且没有指定 extern storage class specifier, 那么这个声明是个 tentative definition(试探性定义)\nint i, v[]; // Tentatiive definitions of i, v and j static int j;  如果一个翻译单元(translation unit)已经包含了一个同名的标示符, 该标示符的的 tentative definition 是一个简单的声明. 否则 compiler 会使 tentative definition 成为一个定义. 因此 int i 和 j 会隐式初始化为0, int array v 初始化包含1个值为0的元素\nComplex Declarators 复杂声明 (), [ ], * 表示 function, array, pointer type\n  () A function whose return value has the type\u0026hellip;\n   An array whose elements have the type\u0026hellip;\n  * A pointer to the type\u0026hellip;\n  int *abc[10]; // An array of q0 elements whose thpe is pointer to int int (*abc)[10]; // A pointer to a array of 10 elements whose type is int int (*fPtr)(double x); // fPtr is a pointer to a function that has one double parameter and return int  解读复杂的声明符\n If a left parenthesis (() or bracket ([) appears immediately to the right, then interpret the pair of parentheses or brackets. Otherwise, if an asterisk (*) appears to the le , interpret the asterisk.  extern char *(* fTab[])(void);     Step Symbols interpreted Meaning(read this column from the top douwn, as a sentence)     Start with the identifier | fTab | fTab is\u0026hellip; Brackets to the right | fTab[] | an array whose elements have the type\u0026hellip; Asterisk to the left. | (* fTab[]) | pointer to\u0026hellip; Function parentheses (and parameter list) to the right. | (* fTab[])(void) | a function, with no parameters, whose return value has the type.. Asterisk to the left. | *(* fTab[])(void) | pointer to\u0026hellip; No more asterishs, parentheses, or brackets: read the type name. | char *(* fTab[])(void) | char.  float (* func())[3][10]; // The identifier func is... // a function whose return value has the type... // pointer to... // an array of three elements of type array of ten elements of type... // float.  Type Names (char *)ptr: char pointer or pointer ot char\nunsigned char: The type unsigned char\nunsigned char *: The type \u0026ldquo;pointer to unsigned char\u0026rdquo;\nfloat *[]: The type \u0026ldquo;array of pointer to float\u0026rdquo;\nfloat (*)[10]: The type \u0026ldquo;pointer to an array of ten elements whose type is float\u0026rdquo;\ndouble *(double *): The type \u0026ldquo;function whose only parameter has the type pointer to double, and which also returns a pointer to double\u0026rdquo;\ndouble (*)(): The type \u0026ldquo;pointer to a function whose return value has the type double\u0026rdquo;\nint *(*(*)[10])(void): The type \u0026ldquo;pointer to an array of ten elements whose type is pointer to a function with no paramemters which return s a pointer to int\u0026rdquo;\nLinkage of Identifiers External Linkage external linkage 在整个程序种代表同一个 function 或 object. compiler 会将它们呈现给 linker, 对 linker 可见, 在其他翻译单元或库中连接它们\u2028extern 声明的 function 和 object(variable) 都具有 external linkage, 除了在同一作用域内, 一个标示符已被定义为 internal linkage, 第二次声明不能将其修改为 external\n没有指定 storage class specifier 的 function 声明 或是 声明在所有 functions 外部没有指定 storage class specifier 的 object 都具有 external linkage\nInternal Linkage internal linkage 在指定翻译单元内代表同一个 function 或 object. compiler 不会将它们呈现给 linker, 对 linker 不可见, 在其他单元不可用\n在所有 functions 外部, 带有 static 的标示符都具有 internal linkage\n不同翻译单元中具有相同名称的标示符没有冲突, 不能在同一翻译单元将已被声明为 internal linkage 的 object 重新声明为 external linkage\nNo Linkage 既没有 external 和 internal 的标示符具有 no linkage\nint func1( void ); // func1 has external linkage int a; // a has external linkage extern int b = 1; // b has external linkage static int c; // c has internal linkage static void func2( int d ) { // func2 has internal linkage; d has no linkage extern int a; // This a is the same as that above, with external linkage int b = 2; // This b has no linkage, and hides th external b declared above extern int c; // This c is the same as that above, and retains internal linkage static int e:; // e has no linkage }  Storage Duration of Objects lifetime: 在程序运行期间, 每个 object 在某个时间段存在与内存某个地方. 这个时间段以外都无法访问这个 object\n4种 storage duration: static, thread, automatic, allocated.\nStatic Storage Duration 定义在所有函数外部, 或通过 storage class specifier static 函数内部定义. 包括所有的 internal linkage 和 external linkage\n在程序运行之前生成并初始化 static storage duration object. 程序的执行时间就是其 lifetime\nThread Storage Duration thread_local: _Thread_local 定义的标示符. 整个 thread 的运行时间是其 lifetime. 每个 thread 在 start 时, 分别初始化 object 的实例\nAutomatic Storage Duration 没有任何 storage class specifier 或是 指定 auto 都具有 automatic storage duration. function 的参数具有 automatic storage duration. 简称 automatic variables\n任何 {} 块中划定了 automatic variables 的 lifetime. variable-length array 例外, 其 lifetime 开始于 point 的声明, 终于该标示符的作用域, 或在 jump 指令之前声明\nInitialization Implicit Initialization 任何 automatic variable 如果为进行初始化, 都有未定义的初始化值. 其他 static storage duration 都会隐式的初始化0, 除非确切的进行了初始化\n 具有算数类型的 object, 默认初始化为 0 pointer object 默认为 NULL  structure, array 按照上述规则进行初始化\nExplicit Initialization 通过等号(=)显式的初始化 object 的值\nstatic storage duration 一定是 constant expressions, automatic 不受此限制\nlength-variable array 不能初始化, const 必须要进行初始化并且后续不能修改它\n","id":14,"section":"posts","summary":"\u003cp\u003e\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 声明\u003c/p\u003e","tags":["C"],"title":"Declarations","uri":"https://www.luyang.ink/2016/04/declarations/","year":"2016"},{"content":"\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 结构体\nDefining Structure Types  struct [tag_name] { member_declaration_list };\n struct Date { short month, day, year; }  member 中不能包含自己, 因为在最后 } 前该结构定义不完整, 除非是 self-referential structures (自引用结构)\nStructure Objects and typedef Names  structure object == structure vaiables\n struct Song song1, song2, *pSong = \u0026amp;song1; // song1, song2 是 struct Song 的对象, 而 *pSong 是指向对象 song1 的指针  每次定义变量都需要包含 struct Song 关键字, 可以用 typedef 定义一个 one-word 结构名称\ntypedef struct Song Song_t; // Song_t 等同于 struct Song Song_t song1, song2 *pSong = \u0026amp;song1; // 2个 struct Song 对象和1个指针  定义一个 struct 时可以不需要定义 tag_name, 这种方式只适用于定义 struct 时同时定义了structure objects, 或这是在 typedef 中声明了 structure type\ntypedef struct { struct Cell *pFirst, *pLast; } SongList_t;  Incomplete Structure Types 可以定义一个指向结构的指针即使这个结构还未定义, 上面 SongList_t 定义是正确的, 虽然 struct Cell 未定义. 这种情况下, SongList_t 会隐式声明 一个 structure tag Cell, 但是直到明确定义 Cell 前, Cell 都是不完整的, 并且 *pFirst, *pLast 指针也不能用来访问 objects\n这样可以用来声明互相应用彼此的 structure type\nstruct A { struct B *pB; /* ... other members of struct A ... */}; struct B { struct A *pA; /* ... other members of struct B ... */};  以上情况有个例外, 如下:\nstruct B { struct A *pA; int key[10]; }; { struct A { struct B pB; // 此时变量 pb 为 block 外层 struct B int key; }; printf(\u0026quot;%d\u0026quot;, sizeof(struct A)); struct B { struct A *pA; int key; }; }  为了避免上述情况可以采取一下方式\nstruct B; // incomplete type struct A { struct B *pB; /* ... */ }; struct B { struct A *pA; /* ... */ };  Accessing Structure Members 2种方式, dot operator(.) 和 arrow operator(-\u0026gt;)\n . : 左值是 structure object(variable) 变量 -\u0026gt; : 左值是 structure point 指针   p-\u0026gt;m == (*p).m\n Initializing Structures Song_t mySong = { \u0026quot;what it is\u0026quot;, \u0026quot;Aubrey Haynie: Mark Knopfler\u0026quot;, \u0026quot;Mark Knopfler\u0026quot;, 297, { 9, 26, 200 } } Song_t yourSong = { \u0026quot;El Macho\u0026quot; }; Song_t yourSong = { \u0026quot;El Macho\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;\u0026quot;, 0, { 0, 0, 0} }; Song_t yourSong = mySong; // 可以是其他已存在的structure变量  Initializing Specific Members  .member // member designator\n Song_t aSong = { .title = \u0026quot;I've Just Seen a Face\u0026quot;, .composer = \u0026quot;John Lennon; Paul McCartney\u0026quot;, 127 }  Structure Members in Memory 等同与 member 声明顺序, 第一个 member 地址 == structure object 地址 为了快速访问 member, compiler 会按照某种对齐方式进行对齐操作, 会在最后一个 member 后增加额外的 bytes 统称 padding, 这就导致 structure 实际的大小大与 members 的大小\n你可以控制 compiler 的对齐操作, 防止 member 之间的缝隙(gap), 通过 complier 的选项, 例如 GCC 的 -fpack-struct\nFlexible Structure members typedef struct { int len; float array[]; } DynArray_t;   以 flexible member 结尾的 structure 的大小等于 flexible member 的偏移量   sizeof(DynArray_t) == offsetof(DynArray_t, array)\n  通过 . 和 -\u0026gt; 访问 flexiable member 时, 要确保 flexiable member 有足够大的空间, 可以通过 malloc 申请所需要的内存大小  DynArray_t *daPtr = malloc(sizeof(DynArrray_t) + 10*sizeof(float)); DynArray_t da1 = { 100 }, // OK da2 = { 3, { 1.0F, 0.5F, 0.25F } }; // Error 看compiler是否支持  Pointer as Structure Members typedef struct { struct Cell *pFirst, *pLast; } SongList_t; typedef struct { struct Song song; struct Cell *pNext; } Cell_t;  Unions 所有 members 共用同一内存地址\nDefining Union Types  ** union [tag_name] { membber_declaration_list };\n union Data { int i; double x; char str[16]; }  union VS structure members 占用内存比较\nInitializing Unions 同 Initializing Structure\nAnonymous Structure and Unions union WordByte { short w; struct { char b0, b1 }; // anonymous structure } union WordByte wb = { 256 }; char lowByte = wb.b0; struct Demo { union {\t// anonymous union struct { long a, b; };\t// anonymous structure struct { float x, y; } fl; // named structure } } dObj; dObj.a = 100; // ok dObj.y = 1.0; // wrong 不能直接访问 y, 因为他是 struct fl 的 member dObj.fl.y = 1.0; // ok  Bit-Fields 可以像 structure 和 union 一样通过 member name 来操作 bit\n type [member_name] : width;\n   type bit-field 值的 integer type, 例如: _Bool, signed int, unsigned int, const int\u0026hellip;\n  member_name bit-field 的 name, 可选, 没有指定 name 时无法访问该 bit-field, 可以当做 padding 来确定后续 bit-field 在机器 word 中的位置\n  width bit-field 的 bit 数量, 非负且不能小余 type 的 width\n  struct Date { unsigned int month : 4; // 1 is January; 12 is December unsigned int day : 5; // The day of the month (1 to 31) signed int year : 22; // (-2097152 to +2097151) _Bool isDST : 1; // True if daylight saving time is in effect } struct Date birthday = { 5, 17, 1982 };  n bits 可以代表 2 n次方个不同的值\n","id":15,"section":"posts","summary":"\u003cp\u003e\u0026laquo;C in a Nutshell\u0026raquo;笔记 - 结构体\u003c/p\u003e","tags":["C"],"title":"Structure","uri":"https://www.luyang.ink/2016/04/structure/","year":"2016"},{"content":"PHP中的变量都是存储在一个叫zval的容器中(数据结构), 这个zval中存储着变量的相关信息，其中就包括变量的引用状态(is_ref)和引用次数(refcount)。\ntypedef struct _zval_struct zval; struct _zval_struct { /* Variable information */ zvalue_value value; /* 存储变量的值*/ zend_uint refcount__gc; /* 引用计数 */ zend_uchar type; /* 变量具体类型*/ zend_uchar is_ref__gc; /* 是否引用 1为引用，0不是*/ };  PHP的变量都存储在一个类似于关联数组(associative array)的符号表(symbol table)中，如下图\n引用计数(Reference Counting) $a = $b, 在这个赋值语句中, PHP不会为变量$b创建一个$a的副本，只是将$a的zval中refcount字段增加1\n 变量$a存储着一个『this is』字符串, 它的refcount=1(默认) 将变量$a分别赋值(assign)给$b,$c, 这时没有任何zval的拷贝，只是根据赋值次数对$a的refcount依次增加1, 最终$a的refcount=3(2次赋值操作) 当$c的值发生变化时, 这时会有2个相关的操作, 其所指向$a的refcount减1, 同时创建一个新的zval来保存$c的新值, 其中$c的refcount＝1(默认) unset($b), 会将其链接$a的refcount减1, 此时$a的refcount为1, 变成了它原先的样子 unset($c), 将$c的rerfcount减1, 这时refcount \u0026lt; 1, PHP会销毁用于保存$c的zval所占用的空间  Passing Variables to Functions 在PHP中会有一个全局的符号表(global symbol table), 来保存相关的变量信息, 同样的当执行一个函数(function)时, 也会创建一个符号表来保存函数的局部变量, 当该函数通过return或其他隐式方式返回时, 其创建的符号表也会随之销毁.\n 我们将$a='this is'传递给函数do_something(), 函数将其保存在形参$s中 接下来你看到的操作跟前面说过的$b=$a几乎相同, 除了变量所在的符号表不同-$s存储在调用函数的符号表中, $a的refcount增加2, 而不是1次, 因为在函数的stack中也包含$a的一个reference 当我们给$s赋值一个新值时, $s之前所指向的zval对应refcount减1, 同时一个用来保存$s新值的容器会被创建 当return返回时, 返回值$b获得了一个进入全局符号表的机会, 对应的refcount增加1 当函数执行完毕时, 函数的符号表将会销毁, 在销毁期间PHP引擎将会检查函数符号表中的每一个变量, 对其zval的refcount减1, 如果其refcount等于0, 将启动垃圾回收机制  Introducing References 引用也就是一个变量有2个名字, 也就是说在一个符号表中存在2个不同的key指向同一个zval, 可以通过 =\u0026amp; 引用赋值来创建一个变量的引用\n 变量$a存储着一个『this is』字符串, 它的is_ref=0, refcount=1(默认) 执行$b =\u0026amp; $a 和 $c =\u0026amp; $a之后, $a的refcount增加2变为3, 由于是引用赋值, $a的is_ref变为1. 当is_ref为0时, 有指向zval的变量有变化时, PHP引擎会创建一个新的zval来保存新值, 原始zval的refcount减1, 但是, 当is_ref为1时, 就不是这样了, PHP引擎回直接更新当前zval中的值 如上所说, $b = 42的结果是$a, $b, $c的值都为42 当使用unset($b)时, zval对应的refcount减1, 跟之前描述的一样 再次unset($c), 同上一步一样, zval的refcount减1, 当refcount为1时, is_ref会重置为0, 因为只有2个以上变量指向同一个zval时, 才是一个引用变量, is_ref才会为1  Mixing Assign-by-Value and Assign-by-Reference = 赋值和 =\u0026amp; 引用赋值\n 创建2个变量, $a = \u0026lsquo;this is\u0026rsquo;; $b = $a; 这是普通的赋值操作, 这时$a,$b所指向的zval的refcount=2, is_ref=0 $c = \u0026amp;b, 这时PHP引擎会创建一个$b所指向zval的副本, $a还是指向原来的zval, 只不过对应的refcount减1, 而$b和$c则会指向刚刚创建的zval, 同时该zval的refcount = 2, is_ref = 1  这种情况使用引用不会为你节省内存空间, 有可能适得其反. 因为PHP引擎要保证变量再赋值(reassignment)操作正确, 所以在=和=\u0026amp;混用的情况下,会有zval的副本产生. 再看下, 将上述赋值顺序颠倒一下的情况\n 这次反过来 $a = \u0026lsquo;this is\u0026rsquo;; $b =\u0026amp; $a; 引用赋值, 此时$a, $b所指向的zval的refcount=2, is_ref=1 $c = $a, 普通赋值, PHP引擎为了变量的再赋值操作的处理, 这里又新建了一个zval的副本来存放$c的值, 此时$c的refcount=1, is_ref=0 ","id":16,"section":"posts","summary":"\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003ePHP中的变量都是存储在一个叫zval的容器中(数据结构), 这个zval中存储着变量的相关信息，其中就包括变量的引用状态(is_ref)和引用次数(refcount)。\u003c/p\u003e","tags":["PHP"],"title":"references in php","uri":"https://www.luyang.ink/2014/11/references-in-php/","year":"2014"}],"tags":[{"title":"C","uri":"https://www.luyang.ink/tags/c/"},{"title":"Go","uri":"https://www.luyang.ink/tags/go/"},{"title":"Homebrew","uri":"https://www.luyang.ink/tags/homebrew/"},{"title":"MySQL","uri":"https://www.luyang.ink/tags/mysql/"},{"title":"PHP","uri":"https://www.luyang.ink/tags/php/"}]}